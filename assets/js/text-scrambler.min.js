class TextScrambler {constructor(options = {}) {this.options = {scrambleRadius: options.scrambleRadius || 3, scrambleIterations: options.scrambleIterations || 8, scrambleSpeed: options.scrambleSpeed || 120, targetSelector: options.targetSelector || "[data-scramble]", characters: options.characters || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`\"'\\", ...options,}; this.activeScrambles = new Map(); this.elements = []; this.isEnabled = true; this.init();} init() {if (typeof Splitting === "undefined") {console.warn("TextScrambler: Splitting.js is required but not found"); return;} if (document.readyState === "loading") {document.addEventListener("DOMContentLoaded", () => this.setup());} else {this.setup();}} setup() {this.elements = document.querySelectorAll(this.options.targetSelector); if (this.elements.length === 0) {console.warn( "TextScrambler: No elements found with selector:", this.options.targetSelector ); return;} this.elements.forEach((element) => {if (!element.hasAttribute("data-splitting")) {Splitting({target: element, by: "chars"});}}); this.setupMouseTracking();} setupMouseTracking() {document.addEventListener("mousemove", (e) => {if (!this.isEnabled) return; this.elements.forEach((element) => {this.processElementAtPosition(element, e.clientX, e.clientY);});});} processElementAtPosition(element, mouseX, mouseY) {const rect = element.getBoundingClientRect(); if ( mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom ) {return;} const chars = element.querySelectorAll(".char"); if (chars.length === 0) return; let closestChar = null; let closestDistance = Infinity; let closestIndex = -1; chars.forEach((char, index) => {const charRect = char.getBoundingClientRect(); const charCenterX = charRect.left + charRect.width / 2; const charCenterY = charRect.top + charRect.height / 2; const distance = Math.sqrt( Math.pow(mouseX - charCenterX, 2) + Math.pow(mouseY - charCenterY, 2) ); if (distance < closestDistance) {closestDistance = distance; closestChar = char; closestIndex = index;}}); if (closestIndex === -1) return; const lineChars = this.getLineChars(chars, closestIndex); const charIndexInLine = lineChars.indexOf(chars[closestIndex]); if (charIndexInLine === -1) return; const startIndex = Math.max( 0, charIndexInLine - this.options.scrambleRadius ); const endIndex = Math.min( lineChars.length - 1, charIndexInLine + this.options.scrambleRadius ); for (let i = startIndex; i <= endIndex; i++) {const char = lineChars[i]; if (char && !this.activeScrambles.has(char)) {this.scrambleCharacter(char);}}} getLineChars(allChars, targetIndex) {const targetChar = allChars[targetIndex]; const targetRect = targetChar.getBoundingClientRect(); const targetY = targetRect.top; const tolerance = targetRect.height * 0.5; const lineChars = []; allChars.forEach((char) => {const charRect = char.getBoundingClientRect(); if (Math.abs(charRect.top - targetY) <= tolerance) {lineChars.push(char);}}); lineChars.sort((a, b) => {const aRect = a.getBoundingClientRect(); const bRect = b.getBoundingClientRect(); return aRect.left - bRect.left;}); return lineChars;} scrambleCharacter(charElement) {if (this.activeScrambles.has(charElement)) return; const originalText = charElement.textContent; let iteration = 0; this.activeScrambles.set(charElement, originalText); const scrambleInterval = setInterval(() => {if (iteration < this.options.scrambleIterations) {const randomChar = this.options.characters[ Math.floor(Math.random() * this.options.characters.length) ]; charElement.textContent = randomChar; iteration++;} else {charElement.textContent = originalText; clearInterval(scrambleInterval); this.activeScrambles.delete(charElement);}}, this.options.scrambleSpeed);} enable() {this.isEnabled = true;} disable() {this.isEnabled = false; this.activeScrambles.forEach((originalText, charElement) => {charElement.textContent = originalText;}); this.activeScrambles.clear();} destroy() {this.disable(); this.elements = []; this.activeScrambles.clear();} updateOptions(newOptions) {this.options = {...this.options, ...newOptions};}} document.addEventListener("DOMContentLoaded", () => {const scrambleElements = document.querySelectorAll("[data-scramble]"); if (scrambleElements.length > 0) {window.textScrambler = new TextScrambler();}}); window.TextScrambler = TextScrambler;